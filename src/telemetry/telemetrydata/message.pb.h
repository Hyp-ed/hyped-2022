// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_INCLUDED_message_2eproto
#define PROTOBUF_INCLUDED_message_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_message_2eproto 

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_message_2eproto
namespace telemetry_data {
class ClientToServer;
class ClientToServerDefaultTypeInternal;
extern ClientToServerDefaultTypeInternal _ClientToServer_default_instance_;
class ClientToServer_Batteries;
class ClientToServer_BatteriesDefaultTypeInternal;
extern ClientToServer_BatteriesDefaultTypeInternal _ClientToServer_Batteries_default_instance_;
class ClientToServer_Batteries_BatteryData;
class ClientToServer_Batteries_BatteryDataDefaultTypeInternal;
extern ClientToServer_Batteries_BatteryDataDefaultTypeInternal _ClientToServer_Batteries_BatteryData_default_instance_;
class ClientToServer_EmergencyBrakes;
class ClientToServer_EmergencyBrakesDefaultTypeInternal;
extern ClientToServer_EmergencyBrakesDefaultTypeInternal _ClientToServer_EmergencyBrakes_default_instance_;
class ClientToServer_Motors;
class ClientToServer_MotorsDefaultTypeInternal;
extern ClientToServer_MotorsDefaultTypeInternal _ClientToServer_Motors_default_instance_;
class ClientToServer_Navigation;
class ClientToServer_NavigationDefaultTypeInternal;
extern ClientToServer_NavigationDefaultTypeInternal _ClientToServer_Navigation_default_instance_;
class ClientToServer_Sensors;
class ClientToServer_SensorsDefaultTypeInternal;
extern ClientToServer_SensorsDefaultTypeInternal _ClientToServer_Sensors_default_instance_;
class ClientToServer_Sensors_ImuData;
class ClientToServer_Sensors_ImuDataDefaultTypeInternal;
extern ClientToServer_Sensors_ImuDataDefaultTypeInternal _ClientToServer_Sensors_ImuData_default_instance_;
class ClientToServer_StateMachine;
class ClientToServer_StateMachineDefaultTypeInternal;
extern ClientToServer_StateMachineDefaultTypeInternal _ClientToServer_StateMachine_default_instance_;
class ClientToServer_Temperature;
class ClientToServer_TemperatureDefaultTypeInternal;
extern ClientToServer_TemperatureDefaultTypeInternal _ClientToServer_Temperature_default_instance_;
class ServerToClient;
class ServerToClientDefaultTypeInternal;
extern ServerToClientDefaultTypeInternal _ServerToClient_default_instance_;
}  // namespace telemetry_data
namespace google {
namespace protobuf {
template<> ::telemetry_data::ClientToServer* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer>(Arena*);
template<> ::telemetry_data::ClientToServer_Batteries* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Batteries>(Arena*);
template<> ::telemetry_data::ClientToServer_Batteries_BatteryData* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Batteries_BatteryData>(Arena*);
template<> ::telemetry_data::ClientToServer_EmergencyBrakes* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_EmergencyBrakes>(Arena*);
template<> ::telemetry_data::ClientToServer_Motors* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Motors>(Arena*);
template<> ::telemetry_data::ClientToServer_Navigation* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Navigation>(Arena*);
template<> ::telemetry_data::ClientToServer_Sensors* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Sensors>(Arena*);
template<> ::telemetry_data::ClientToServer_Sensors_ImuData* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Sensors_ImuData>(Arena*);
template<> ::telemetry_data::ClientToServer_StateMachine* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_StateMachine>(Arena*);
template<> ::telemetry_data::ClientToServer_Temperature* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Temperature>(Arena*);
template<> ::telemetry_data::ServerToClient* Arena::CreateMaybeMessage<::telemetry_data::ServerToClient>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace telemetry_data {

enum ServerToClient_Command {
  ServerToClient_Command_ACK = 0,
  ServerToClient_Command_STOP = 1,
  ServerToClient_Command_CALIBRATE = 2,
  ServerToClient_Command_LAUNCH = 3,
  ServerToClient_Command_RESET = 4,
  ServerToClient_Command_SERVICE_PROPULSION_GO = 5,
  ServerToClient_Command_SERVICE_PROPULSION_STOP = 6,
  ServerToClient_Command_NOMINAL_BRAKING = 7,
  ServerToClient_Command_NOMINAL_RETRACT = 8,
  ServerToClient_Command_ServerToClient_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServerToClient_Command_ServerToClient_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServerToClient_Command_IsValid(int value);
const ServerToClient_Command ServerToClient_Command_Command_MIN = ServerToClient_Command_ACK;
const ServerToClient_Command ServerToClient_Command_Command_MAX = ServerToClient_Command_NOMINAL_RETRACT;
const int ServerToClient_Command_Command_ARRAYSIZE = ServerToClient_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerToClient_Command_descriptor();
inline const ::std::string& ServerToClient_Command_Name(ServerToClient_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerToClient_Command_descriptor(), value);
}
inline bool ServerToClient_Command_Parse(
    const ::std::string& name, ServerToClient_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerToClient_Command>(
    ServerToClient_Command_descriptor(), name, value);
}
enum ClientToServer_StateMachine_State {
  ClientToServer_StateMachine_State_INVALID = 0,
  ClientToServer_StateMachine_State_IDLE = 1,
  ClientToServer_StateMachine_State_CALIBRATING = 2,
  ClientToServer_StateMachine_State_READY = 3,
  ClientToServer_StateMachine_State_ACCELERATING = 4,
  ClientToServer_StateMachine_State_NOMINAL_BRAKING = 5,
  ClientToServer_StateMachine_State_EMERGENCY_BRAKING = 6,
  ClientToServer_StateMachine_State_RUN_COMPLETE = 7,
  ClientToServer_StateMachine_State_FAILURE_STOPPED = 8,
  ClientToServer_StateMachine_State_EXITING = 9,
  ClientToServer_StateMachine_State_FINISHED = 10,
  ClientToServer_StateMachine_State_ClientToServer_StateMachine_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ClientToServer_StateMachine_State_ClientToServer_StateMachine_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ClientToServer_StateMachine_State_IsValid(int value);
const ClientToServer_StateMachine_State ClientToServer_StateMachine_State_State_MIN = ClientToServer_StateMachine_State_INVALID;
const ClientToServer_StateMachine_State ClientToServer_StateMachine_State_State_MAX = ClientToServer_StateMachine_State_FINISHED;
const int ClientToServer_StateMachine_State_State_ARRAYSIZE = ClientToServer_StateMachine_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientToServer_StateMachine_State_descriptor();
inline const ::std::string& ClientToServer_StateMachine_State_Name(ClientToServer_StateMachine_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientToServer_StateMachine_State_descriptor(), value);
}
inline bool ClientToServer_StateMachine_State_Parse(
    const ::std::string& name, ClientToServer_StateMachine_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientToServer_StateMachine_State>(
    ClientToServer_StateMachine_State_descriptor(), name, value);
}
enum ClientToServer_ModuleStatus {
  ClientToServer_ModuleStatus_START = 0,
  ClientToServer_ModuleStatus_INIT = 1,
  ClientToServer_ModuleStatus_READY = 2,
  ClientToServer_ModuleStatus_CRITICAL_FAILURE = 3,
  ClientToServer_ModuleStatus_ClientToServer_ModuleStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ClientToServer_ModuleStatus_ClientToServer_ModuleStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ClientToServer_ModuleStatus_IsValid(int value);
const ClientToServer_ModuleStatus ClientToServer_ModuleStatus_ModuleStatus_MIN = ClientToServer_ModuleStatus_START;
const ClientToServer_ModuleStatus ClientToServer_ModuleStatus_ModuleStatus_MAX = ClientToServer_ModuleStatus_CRITICAL_FAILURE;
const int ClientToServer_ModuleStatus_ModuleStatus_ARRAYSIZE = ClientToServer_ModuleStatus_ModuleStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientToServer_ModuleStatus_descriptor();
inline const ::std::string& ClientToServer_ModuleStatus_Name(ClientToServer_ModuleStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientToServer_ModuleStatus_descriptor(), value);
}
inline bool ClientToServer_ModuleStatus_Parse(
    const ::std::string& name, ClientToServer_ModuleStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientToServer_ModuleStatus>(
    ClientToServer_ModuleStatus_descriptor(), name, value);
}
// ===================================================================

class ServerToClient : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ServerToClient) */ {
 public:
  ServerToClient();
  virtual ~ServerToClient();

  ServerToClient(const ServerToClient& from);

  inline ServerToClient& operator=(const ServerToClient& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClient(ServerToClient&& from) noexcept
    : ServerToClient() {
    *this = ::std::move(from);
  }

  inline ServerToClient& operator=(ServerToClient&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient* internal_default_instance() {
    return reinterpret_cast<const ServerToClient*>(
               &_ServerToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ServerToClient* other);
  friend void swap(ServerToClient& a, ServerToClient& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient* New() const final {
    return CreateMaybeMessage<ServerToClient>(NULL);
  }

  ServerToClient* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClient& from);
  void MergeFrom(const ServerToClient& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServerToClient_Command Command;
  static const Command ACK =
    ServerToClient_Command_ACK;
  static const Command STOP =
    ServerToClient_Command_STOP;
  static const Command CALIBRATE =
    ServerToClient_Command_CALIBRATE;
  static const Command LAUNCH =
    ServerToClient_Command_LAUNCH;
  static const Command RESET =
    ServerToClient_Command_RESET;
  static const Command SERVICE_PROPULSION_GO =
    ServerToClient_Command_SERVICE_PROPULSION_GO;
  static const Command SERVICE_PROPULSION_STOP =
    ServerToClient_Command_SERVICE_PROPULSION_STOP;
  static const Command NOMINAL_BRAKING =
    ServerToClient_Command_NOMINAL_BRAKING;
  static const Command NOMINAL_RETRACT =
    ServerToClient_Command_NOMINAL_RETRACT;
  static inline bool Command_IsValid(int value) {
    return ServerToClient_Command_IsValid(value);
  }
  static const Command Command_MIN =
    ServerToClient_Command_Command_MIN;
  static const Command Command_MAX =
    ServerToClient_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    ServerToClient_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return ServerToClient_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return ServerToClient_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return ServerToClient_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .telemetry_data.ServerToClient.Command command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::telemetry_data::ServerToClient_Command command() const;
  void set_command(::telemetry_data::ServerToClient_Command value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ServerToClient)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_Navigation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Navigation) */ {
 public:
  ClientToServer_Navigation();
  virtual ~ClientToServer_Navigation();

  ClientToServer_Navigation(const ClientToServer_Navigation& from);

  inline ClientToServer_Navigation& operator=(const ClientToServer_Navigation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_Navigation(ClientToServer_Navigation&& from) noexcept
    : ClientToServer_Navigation() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Navigation& operator=(ClientToServer_Navigation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_Navigation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Navigation* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Navigation*>(
               &_ClientToServer_Navigation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ClientToServer_Navigation* other);
  friend void swap(ClientToServer_Navigation& a, ClientToServer_Navigation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Navigation* New() const final {
    return CreateMaybeMessage<ClientToServer_Navigation>(NULL);
  }

  ClientToServer_Navigation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Navigation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_Navigation& from);
  void MergeFrom(const ClientToServer_Navigation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Navigation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
  void clear_module_status();
  static const int kModuleStatusFieldNumber = 1;
  ::telemetry_data::ClientToServer_ModuleStatus module_status() const;
  void set_module_status(::telemetry_data::ClientToServer_ModuleStatus value);

  // float distance = 2;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // float velocity = 3;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  float velocity() const;
  void set_velocity(float value);

  // float acceleration = 4;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 4;
  float acceleration() const;
  void set_acceleration(float value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Navigation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int module_status_;
  float distance_;
  float velocity_;
  float acceleration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_StateMachine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.StateMachine) */ {
 public:
  ClientToServer_StateMachine();
  virtual ~ClientToServer_StateMachine();

  ClientToServer_StateMachine(const ClientToServer_StateMachine& from);

  inline ClientToServer_StateMachine& operator=(const ClientToServer_StateMachine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_StateMachine(ClientToServer_StateMachine&& from) noexcept
    : ClientToServer_StateMachine() {
    *this = ::std::move(from);
  }

  inline ClientToServer_StateMachine& operator=(ClientToServer_StateMachine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_StateMachine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_StateMachine* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_StateMachine*>(
               &_ClientToServer_StateMachine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClientToServer_StateMachine* other);
  friend void swap(ClientToServer_StateMachine& a, ClientToServer_StateMachine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_StateMachine* New() const final {
    return CreateMaybeMessage<ClientToServer_StateMachine>(NULL);
  }

  ClientToServer_StateMachine* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_StateMachine>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_StateMachine& from);
  void MergeFrom(const ClientToServer_StateMachine& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_StateMachine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientToServer_StateMachine_State State;
  static const State INVALID =
    ClientToServer_StateMachine_State_INVALID;
  static const State IDLE =
    ClientToServer_StateMachine_State_IDLE;
  static const State CALIBRATING =
    ClientToServer_StateMachine_State_CALIBRATING;
  static const State READY =
    ClientToServer_StateMachine_State_READY;
  static const State ACCELERATING =
    ClientToServer_StateMachine_State_ACCELERATING;
  static const State NOMINAL_BRAKING =
    ClientToServer_StateMachine_State_NOMINAL_BRAKING;
  static const State EMERGENCY_BRAKING =
    ClientToServer_StateMachine_State_EMERGENCY_BRAKING;
  static const State RUN_COMPLETE =
    ClientToServer_StateMachine_State_RUN_COMPLETE;
  static const State FAILURE_STOPPED =
    ClientToServer_StateMachine_State_FAILURE_STOPPED;
  static const State EXITING =
    ClientToServer_StateMachine_State_EXITING;
  static const State FINISHED =
    ClientToServer_StateMachine_State_FINISHED;
  static inline bool State_IsValid(int value) {
    return ClientToServer_StateMachine_State_IsValid(value);
  }
  static const State State_MIN =
    ClientToServer_StateMachine_State_State_MIN;
  static const State State_MAX =
    ClientToServer_StateMachine_State_State_MAX;
  static const int State_ARRAYSIZE =
    ClientToServer_StateMachine_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return ClientToServer_StateMachine_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return ClientToServer_StateMachine_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return ClientToServer_StateMachine_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .telemetry_data.ClientToServer.StateMachine.State current_state = 2;
  void clear_current_state();
  static const int kCurrentStateFieldNumber = 2;
  ::telemetry_data::ClientToServer_StateMachine_State current_state() const;
  void set_current_state(::telemetry_data::ClientToServer_StateMachine_State value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.StateMachine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int current_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_Motors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Motors) */ {
 public:
  ClientToServer_Motors();
  virtual ~ClientToServer_Motors();

  ClientToServer_Motors(const ClientToServer_Motors& from);

  inline ClientToServer_Motors& operator=(const ClientToServer_Motors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_Motors(ClientToServer_Motors&& from) noexcept
    : ClientToServer_Motors() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Motors& operator=(ClientToServer_Motors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_Motors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Motors* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Motors*>(
               &_ClientToServer_Motors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ClientToServer_Motors* other);
  friend void swap(ClientToServer_Motors& a, ClientToServer_Motors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Motors* New() const final {
    return CreateMaybeMessage<ClientToServer_Motors>(NULL);
  }

  ClientToServer_Motors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Motors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_Motors& from);
  void MergeFrom(const ClientToServer_Motors& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Motors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
  void clear_module_status();
  static const int kModuleStatusFieldNumber = 1;
  ::telemetry_data::ClientToServer_ModuleStatus module_status() const;
  void set_module_status(::telemetry_data::ClientToServer_ModuleStatus value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Motors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int module_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_Batteries_BatteryData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Batteries.BatteryData) */ {
 public:
  ClientToServer_Batteries_BatteryData();
  virtual ~ClientToServer_Batteries_BatteryData();

  ClientToServer_Batteries_BatteryData(const ClientToServer_Batteries_BatteryData& from);

  inline ClientToServer_Batteries_BatteryData& operator=(const ClientToServer_Batteries_BatteryData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_Batteries_BatteryData(ClientToServer_Batteries_BatteryData&& from) noexcept
    : ClientToServer_Batteries_BatteryData() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Batteries_BatteryData& operator=(ClientToServer_Batteries_BatteryData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_Batteries_BatteryData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Batteries_BatteryData* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Batteries_BatteryData*>(
               &_ClientToServer_Batteries_BatteryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ClientToServer_Batteries_BatteryData* other);
  friend void swap(ClientToServer_Batteries_BatteryData& a, ClientToServer_Batteries_BatteryData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Batteries_BatteryData* New() const final {
    return CreateMaybeMessage<ClientToServer_Batteries_BatteryData>(NULL);
  }

  ClientToServer_Batteries_BatteryData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Batteries_BatteryData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_Batteries_BatteryData& from);
  void MergeFrom(const ClientToServer_Batteries_BatteryData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Batteries_BatteryData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 indv_voltage = 9;
  int indv_voltage_size() const;
  void clear_indv_voltage();
  static const int kIndvVoltageFieldNumber = 9;
  ::google::protobuf::uint32 indv_voltage(int index) const;
  void set_indv_voltage(int index, ::google::protobuf::uint32 value);
  void add_indv_voltage(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      indv_voltage() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_indv_voltage();

  // uint32 voltage = 1;
  void clear_voltage();
  static const int kVoltageFieldNumber = 1;
  ::google::protobuf::uint32 voltage() const;
  void set_voltage(::google::protobuf::uint32 value);

  // sint32 current = 2;
  void clear_current();
  static const int kCurrentFieldNumber = 2;
  ::google::protobuf::int32 current() const;
  void set_current(::google::protobuf::int32 value);

  // uint32 charge = 3;
  void clear_charge();
  static const int kChargeFieldNumber = 3;
  ::google::protobuf::uint32 charge() const;
  void set_charge(::google::protobuf::uint32 value);

  // int32 average_temperature = 4;
  void clear_average_temperature();
  static const int kAverageTemperatureFieldNumber = 4;
  ::google::protobuf::int32 average_temperature() const;
  void set_average_temperature(::google::protobuf::int32 value);

  // int32 low_temperature = 5;
  void clear_low_temperature();
  static const int kLowTemperatureFieldNumber = 5;
  ::google::protobuf::int32 low_temperature() const;
  void set_low_temperature(::google::protobuf::int32 value);

  // int32 high_temperature = 6;
  void clear_high_temperature();
  static const int kHighTemperatureFieldNumber = 6;
  ::google::protobuf::int32 high_temperature() const;
  void set_high_temperature(::google::protobuf::int32 value);

  // uint32 low_voltage_cell = 7;
  void clear_low_voltage_cell();
  static const int kLowVoltageCellFieldNumber = 7;
  ::google::protobuf::uint32 low_voltage_cell() const;
  void set_low_voltage_cell(::google::protobuf::uint32 value);

  // uint32 high_voltage_cell = 8;
  void clear_high_voltage_cell();
  static const int kHighVoltageCellFieldNumber = 8;
  ::google::protobuf::uint32 high_voltage_cell() const;
  void set_high_voltage_cell(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Batteries.BatteryData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > indv_voltage_;
  mutable int _indv_voltage_cached_byte_size_;
  ::google::protobuf::uint32 voltage_;
  ::google::protobuf::int32 current_;
  ::google::protobuf::uint32 charge_;
  ::google::protobuf::int32 average_temperature_;
  ::google::protobuf::int32 low_temperature_;
  ::google::protobuf::int32 high_temperature_;
  ::google::protobuf::uint32 low_voltage_cell_;
  ::google::protobuf::uint32 high_voltage_cell_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_Batteries : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Batteries) */ {
 public:
  ClientToServer_Batteries();
  virtual ~ClientToServer_Batteries();

  ClientToServer_Batteries(const ClientToServer_Batteries& from);

  inline ClientToServer_Batteries& operator=(const ClientToServer_Batteries& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_Batteries(ClientToServer_Batteries&& from) noexcept
    : ClientToServer_Batteries() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Batteries& operator=(ClientToServer_Batteries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_Batteries& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Batteries* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Batteries*>(
               &_ClientToServer_Batteries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ClientToServer_Batteries* other);
  friend void swap(ClientToServer_Batteries& a, ClientToServer_Batteries& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Batteries* New() const final {
    return CreateMaybeMessage<ClientToServer_Batteries>(NULL);
  }

  ClientToServer_Batteries* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Batteries>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_Batteries& from);
  void MergeFrom(const ClientToServer_Batteries& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Batteries* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientToServer_Batteries_BatteryData BatteryData;

  // accessors -------------------------------------------------------

  // repeated .telemetry_data.ClientToServer.Batteries.BatteryData low_power_batteries = 2;
  int low_power_batteries_size() const;
  void clear_low_power_batteries();
  static const int kLowPowerBatteriesFieldNumber = 2;
  ::telemetry_data::ClientToServer_Batteries_BatteryData* mutable_low_power_batteries(int index);
  ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >*
      mutable_low_power_batteries();
  const ::telemetry_data::ClientToServer_Batteries_BatteryData& low_power_batteries(int index) const;
  ::telemetry_data::ClientToServer_Batteries_BatteryData* add_low_power_batteries();
  const ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >&
      low_power_batteries() const;

  // repeated .telemetry_data.ClientToServer.Batteries.BatteryData high_power_batteries = 3;
  int high_power_batteries_size() const;
  void clear_high_power_batteries();
  static const int kHighPowerBatteriesFieldNumber = 3;
  ::telemetry_data::ClientToServer_Batteries_BatteryData* mutable_high_power_batteries(int index);
  ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >*
      mutable_high_power_batteries();
  const ::telemetry_data::ClientToServer_Batteries_BatteryData& high_power_batteries(int index) const;
  ::telemetry_data::ClientToServer_Batteries_BatteryData* add_high_power_batteries();
  const ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >&
      high_power_batteries() const;

  // .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
  void clear_module_status();
  static const int kModuleStatusFieldNumber = 1;
  ::telemetry_data::ClientToServer_ModuleStatus module_status() const;
  void set_module_status(::telemetry_data::ClientToServer_ModuleStatus value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Batteries)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData > low_power_batteries_;
  ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData > high_power_batteries_;
  int module_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_Sensors_ImuData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Sensors.ImuData) */ {
 public:
  ClientToServer_Sensors_ImuData();
  virtual ~ClientToServer_Sensors_ImuData();

  ClientToServer_Sensors_ImuData(const ClientToServer_Sensors_ImuData& from);

  inline ClientToServer_Sensors_ImuData& operator=(const ClientToServer_Sensors_ImuData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_Sensors_ImuData(ClientToServer_Sensors_ImuData&& from) noexcept
    : ClientToServer_Sensors_ImuData() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Sensors_ImuData& operator=(ClientToServer_Sensors_ImuData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_Sensors_ImuData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Sensors_ImuData* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Sensors_ImuData*>(
               &_ClientToServer_Sensors_ImuData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ClientToServer_Sensors_ImuData* other);
  friend void swap(ClientToServer_Sensors_ImuData& a, ClientToServer_Sensors_ImuData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Sensors_ImuData* New() const final {
    return CreateMaybeMessage<ClientToServer_Sensors_ImuData>(NULL);
  }

  ClientToServer_Sensors_ImuData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Sensors_ImuData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_Sensors_ImuData& from);
  void MergeFrom(const ClientToServer_Sensors_ImuData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Sensors_ImuData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float acc = 2;
  int acc_size() const;
  void clear_acc();
  static const int kAccFieldNumber = 2;
  float acc(int index) const;
  void set_acc(int index, float value);
  void add_acc(float value);
  const ::google::protobuf::RepeatedField< float >&
      acc() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_acc();

  // bool operational = 1;
  void clear_operational();
  static const int kOperationalFieldNumber = 1;
  bool operational() const;
  void set_operational(bool value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Sensors.ImuData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > acc_;
  mutable int _acc_cached_byte_size_;
  bool operational_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_Sensors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Sensors) */ {
 public:
  ClientToServer_Sensors();
  virtual ~ClientToServer_Sensors();

  ClientToServer_Sensors(const ClientToServer_Sensors& from);

  inline ClientToServer_Sensors& operator=(const ClientToServer_Sensors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_Sensors(ClientToServer_Sensors&& from) noexcept
    : ClientToServer_Sensors() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Sensors& operator=(ClientToServer_Sensors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_Sensors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Sensors* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Sensors*>(
               &_ClientToServer_Sensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ClientToServer_Sensors* other);
  friend void swap(ClientToServer_Sensors& a, ClientToServer_Sensors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Sensors* New() const final {
    return CreateMaybeMessage<ClientToServer_Sensors>(NULL);
  }

  ClientToServer_Sensors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Sensors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_Sensors& from);
  void MergeFrom(const ClientToServer_Sensors& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Sensors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientToServer_Sensors_ImuData ImuData;

  // accessors -------------------------------------------------------

  // repeated .telemetry_data.ClientToServer.Sensors.ImuData imu = 2;
  int imu_size() const;
  void clear_imu();
  static const int kImuFieldNumber = 2;
  ::telemetry_data::ClientToServer_Sensors_ImuData* mutable_imu(int index);
  ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData >*
      mutable_imu();
  const ::telemetry_data::ClientToServer_Sensors_ImuData& imu(int index) const;
  ::telemetry_data::ClientToServer_Sensors_ImuData* add_imu();
  const ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData >&
      imu() const;

  // .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
  void clear_module_status();
  static const int kModuleStatusFieldNumber = 1;
  ::telemetry_data::ClientToServer_ModuleStatus module_status() const;
  void set_module_status(::telemetry_data::ClientToServer_ModuleStatus value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Sensors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData > imu_;
  int module_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_Temperature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Temperature) */ {
 public:
  ClientToServer_Temperature();
  virtual ~ClientToServer_Temperature();

  ClientToServer_Temperature(const ClientToServer_Temperature& from);

  inline ClientToServer_Temperature& operator=(const ClientToServer_Temperature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_Temperature(ClientToServer_Temperature&& from) noexcept
    : ClientToServer_Temperature() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Temperature& operator=(ClientToServer_Temperature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_Temperature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Temperature* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Temperature*>(
               &_ClientToServer_Temperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ClientToServer_Temperature* other);
  friend void swap(ClientToServer_Temperature& a, ClientToServer_Temperature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Temperature* New() const final {
    return CreateMaybeMessage<ClientToServer_Temperature>(NULL);
  }

  ClientToServer_Temperature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Temperature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_Temperature& from);
  void MergeFrom(const ClientToServer_Temperature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Temperature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 temperature = 1;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 1;
  ::google::protobuf::int32 temperature() const;
  void set_temperature(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Temperature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 temperature_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer_EmergencyBrakes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.EmergencyBrakes) */ {
 public:
  ClientToServer_EmergencyBrakes();
  virtual ~ClientToServer_EmergencyBrakes();

  ClientToServer_EmergencyBrakes(const ClientToServer_EmergencyBrakes& from);

  inline ClientToServer_EmergencyBrakes& operator=(const ClientToServer_EmergencyBrakes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer_EmergencyBrakes(ClientToServer_EmergencyBrakes&& from) noexcept
    : ClientToServer_EmergencyBrakes() {
    *this = ::std::move(from);
  }

  inline ClientToServer_EmergencyBrakes& operator=(ClientToServer_EmergencyBrakes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer_EmergencyBrakes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_EmergencyBrakes* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_EmergencyBrakes*>(
               &_ClientToServer_EmergencyBrakes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ClientToServer_EmergencyBrakes* other);
  friend void swap(ClientToServer_EmergencyBrakes& a, ClientToServer_EmergencyBrakes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_EmergencyBrakes* New() const final {
    return CreateMaybeMessage<ClientToServer_EmergencyBrakes>(NULL);
  }

  ClientToServer_EmergencyBrakes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_EmergencyBrakes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer_EmergencyBrakes& from);
  void MergeFrom(const ClientToServer_EmergencyBrakes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_EmergencyBrakes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool brakes = 1;
  int brakes_size() const;
  void clear_brakes();
  static const int kBrakesFieldNumber = 1;
  bool brakes(int index) const;
  void set_brakes(int index, bool value);
  void add_brakes(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      brakes() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_brakes();

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.EmergencyBrakes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< bool > brakes_;
  mutable int _brakes_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer) */ {
 public:
  ClientToServer();
  virtual ~ClientToServer();

  ClientToServer(const ClientToServer& from);

  inline ClientToServer& operator=(const ClientToServer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServer(ClientToServer&& from) noexcept
    : ClientToServer() {
    *this = ::std::move(from);
  }

  inline ClientToServer& operator=(ClientToServer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer* internal_default_instance() {
    return reinterpret_cast<const ClientToServer*>(
               &_ClientToServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ClientToServer* other);
  friend void swap(ClientToServer& a, ClientToServer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer* New() const final {
    return CreateMaybeMessage<ClientToServer>(NULL);
  }

  ClientToServer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServer& from);
  void MergeFrom(const ClientToServer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientToServer_Navigation Navigation;
  typedef ClientToServer_StateMachine StateMachine;
  typedef ClientToServer_Motors Motors;
  typedef ClientToServer_Batteries Batteries;
  typedef ClientToServer_Sensors Sensors;
  typedef ClientToServer_Temperature Temperature;
  typedef ClientToServer_EmergencyBrakes EmergencyBrakes;

  typedef ClientToServer_ModuleStatus ModuleStatus;
  static const ModuleStatus START =
    ClientToServer_ModuleStatus_START;
  static const ModuleStatus INIT =
    ClientToServer_ModuleStatus_INIT;
  static const ModuleStatus READY =
    ClientToServer_ModuleStatus_READY;
  static const ModuleStatus CRITICAL_FAILURE =
    ClientToServer_ModuleStatus_CRITICAL_FAILURE;
  static inline bool ModuleStatus_IsValid(int value) {
    return ClientToServer_ModuleStatus_IsValid(value);
  }
  static const ModuleStatus ModuleStatus_MIN =
    ClientToServer_ModuleStatus_ModuleStatus_MIN;
  static const ModuleStatus ModuleStatus_MAX =
    ClientToServer_ModuleStatus_ModuleStatus_MAX;
  static const int ModuleStatus_ARRAYSIZE =
    ClientToServer_ModuleStatus_ModuleStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ModuleStatus_descriptor() {
    return ClientToServer_ModuleStatus_descriptor();
  }
  static inline const ::std::string& ModuleStatus_Name(ModuleStatus value) {
    return ClientToServer_ModuleStatus_Name(value);
  }
  static inline bool ModuleStatus_Parse(const ::std::string& name,
      ModuleStatus* value) {
    return ClientToServer_ModuleStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .telemetry_data.ClientToServer.Navigation navigation = 1;
  bool has_navigation() const;
  void clear_navigation();
  static const int kNavigationFieldNumber = 1;
  private:
  const ::telemetry_data::ClientToServer_Navigation& _internal_navigation() const;
  public:
  const ::telemetry_data::ClientToServer_Navigation& navigation() const;
  ::telemetry_data::ClientToServer_Navigation* release_navigation();
  ::telemetry_data::ClientToServer_Navigation* mutable_navigation();
  void set_allocated_navigation(::telemetry_data::ClientToServer_Navigation* navigation);

  // .telemetry_data.ClientToServer.StateMachine state_machine = 2;
  bool has_state_machine() const;
  void clear_state_machine();
  static const int kStateMachineFieldNumber = 2;
  private:
  const ::telemetry_data::ClientToServer_StateMachine& _internal_state_machine() const;
  public:
  const ::telemetry_data::ClientToServer_StateMachine& state_machine() const;
  ::telemetry_data::ClientToServer_StateMachine* release_state_machine();
  ::telemetry_data::ClientToServer_StateMachine* mutable_state_machine();
  void set_allocated_state_machine(::telemetry_data::ClientToServer_StateMachine* state_machine);

  // .telemetry_data.ClientToServer.Motors motors = 3;
  bool has_motors() const;
  void clear_motors();
  static const int kMotorsFieldNumber = 3;
  private:
  const ::telemetry_data::ClientToServer_Motors& _internal_motors() const;
  public:
  const ::telemetry_data::ClientToServer_Motors& motors() const;
  ::telemetry_data::ClientToServer_Motors* release_motors();
  ::telemetry_data::ClientToServer_Motors* mutable_motors();
  void set_allocated_motors(::telemetry_data::ClientToServer_Motors* motors);

  // .telemetry_data.ClientToServer.Batteries batteries = 4;
  bool has_batteries() const;
  void clear_batteries();
  static const int kBatteriesFieldNumber = 4;
  private:
  const ::telemetry_data::ClientToServer_Batteries& _internal_batteries() const;
  public:
  const ::telemetry_data::ClientToServer_Batteries& batteries() const;
  ::telemetry_data::ClientToServer_Batteries* release_batteries();
  ::telemetry_data::ClientToServer_Batteries* mutable_batteries();
  void set_allocated_batteries(::telemetry_data::ClientToServer_Batteries* batteries);

  // .telemetry_data.ClientToServer.Sensors sensors = 5;
  bool has_sensors() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 5;
  private:
  const ::telemetry_data::ClientToServer_Sensors& _internal_sensors() const;
  public:
  const ::telemetry_data::ClientToServer_Sensors& sensors() const;
  ::telemetry_data::ClientToServer_Sensors* release_sensors();
  ::telemetry_data::ClientToServer_Sensors* mutable_sensors();
  void set_allocated_sensors(::telemetry_data::ClientToServer_Sensors* sensors);

  // .telemetry_data.ClientToServer.Temperature temperature = 6;
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 6;
  private:
  const ::telemetry_data::ClientToServer_Temperature& _internal_temperature() const;
  public:
  const ::telemetry_data::ClientToServer_Temperature& temperature() const;
  ::telemetry_data::ClientToServer_Temperature* release_temperature();
  ::telemetry_data::ClientToServer_Temperature* mutable_temperature();
  void set_allocated_temperature(::telemetry_data::ClientToServer_Temperature* temperature);

  // .telemetry_data.ClientToServer.EmergencyBrakes emergency_brakes = 7;
  bool has_emergency_brakes() const;
  void clear_emergency_brakes();
  static const int kEmergencyBrakesFieldNumber = 7;
  private:
  const ::telemetry_data::ClientToServer_EmergencyBrakes& _internal_emergency_brakes() const;
  public:
  const ::telemetry_data::ClientToServer_EmergencyBrakes& emergency_brakes() const;
  ::telemetry_data::ClientToServer_EmergencyBrakes* release_emergency_brakes();
  ::telemetry_data::ClientToServer_EmergencyBrakes* mutable_emergency_brakes();
  void set_allocated_emergency_brakes(::telemetry_data::ClientToServer_EmergencyBrakes* emergency_brakes);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::telemetry_data::ClientToServer_Navigation* navigation_;
  ::telemetry_data::ClientToServer_StateMachine* state_machine_;
  ::telemetry_data::ClientToServer_Motors* motors_;
  ::telemetry_data::ClientToServer_Batteries* batteries_;
  ::telemetry_data::ClientToServer_Sensors* sensors_;
  ::telemetry_data::ClientToServer_Temperature* temperature_;
  ::telemetry_data::ClientToServer_EmergencyBrakes* emergency_brakes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerToClient

// .telemetry_data.ServerToClient.Command command = 1;
inline void ServerToClient::clear_command() {
  command_ = 0;
}
inline ::telemetry_data::ServerToClient_Command ServerToClient::command() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ServerToClient.command)
  return static_cast< ::telemetry_data::ServerToClient_Command >(command_);
}
inline void ServerToClient::set_command(::telemetry_data::ServerToClient_Command value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ServerToClient.command)
}

// -------------------------------------------------------------------

// ClientToServer_Navigation

// .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
inline void ClientToServer_Navigation::clear_module_status() {
  module_status_ = 0;
}
inline ::telemetry_data::ClientToServer_ModuleStatus ClientToServer_Navigation::module_status() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Navigation.module_status)
  return static_cast< ::telemetry_data::ClientToServer_ModuleStatus >(module_status_);
}
inline void ClientToServer_Navigation::set_module_status(::telemetry_data::ClientToServer_ModuleStatus value) {
  
  module_status_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Navigation.module_status)
}

// float distance = 2;
inline void ClientToServer_Navigation::clear_distance() {
  distance_ = 0;
}
inline float ClientToServer_Navigation::distance() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Navigation.distance)
  return distance_;
}
inline void ClientToServer_Navigation::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Navigation.distance)
}

// float velocity = 3;
inline void ClientToServer_Navigation::clear_velocity() {
  velocity_ = 0;
}
inline float ClientToServer_Navigation::velocity() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Navigation.velocity)
  return velocity_;
}
inline void ClientToServer_Navigation::set_velocity(float value) {
  
  velocity_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Navigation.velocity)
}

// float acceleration = 4;
inline void ClientToServer_Navigation::clear_acceleration() {
  acceleration_ = 0;
}
inline float ClientToServer_Navigation::acceleration() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Navigation.acceleration)
  return acceleration_;
}
inline void ClientToServer_Navigation::set_acceleration(float value) {
  
  acceleration_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Navigation.acceleration)
}

// -------------------------------------------------------------------

// ClientToServer_StateMachine

// .telemetry_data.ClientToServer.StateMachine.State current_state = 2;
inline void ClientToServer_StateMachine::clear_current_state() {
  current_state_ = 0;
}
inline ::telemetry_data::ClientToServer_StateMachine_State ClientToServer_StateMachine::current_state() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.StateMachine.current_state)
  return static_cast< ::telemetry_data::ClientToServer_StateMachine_State >(current_state_);
}
inline void ClientToServer_StateMachine::set_current_state(::telemetry_data::ClientToServer_StateMachine_State value) {
  
  current_state_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.StateMachine.current_state)
}

// -------------------------------------------------------------------

// ClientToServer_Motors

// .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
inline void ClientToServer_Motors::clear_module_status() {
  module_status_ = 0;
}
inline ::telemetry_data::ClientToServer_ModuleStatus ClientToServer_Motors::module_status() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Motors.module_status)
  return static_cast< ::telemetry_data::ClientToServer_ModuleStatus >(module_status_);
}
inline void ClientToServer_Motors::set_module_status(::telemetry_data::ClientToServer_ModuleStatus value) {
  
  module_status_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Motors.module_status)
}

// -------------------------------------------------------------------

// ClientToServer_Batteries_BatteryData

// uint32 voltage = 1;
inline void ClientToServer_Batteries_BatteryData::clear_voltage() {
  voltage_ = 0u;
}
inline ::google::protobuf::uint32 ClientToServer_Batteries_BatteryData::voltage() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.voltage)
  return voltage_;
}
inline void ClientToServer_Batteries_BatteryData::set_voltage(::google::protobuf::uint32 value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.voltage)
}

// sint32 current = 2;
inline void ClientToServer_Batteries_BatteryData::clear_current() {
  current_ = 0;
}
inline ::google::protobuf::int32 ClientToServer_Batteries_BatteryData::current() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.current)
  return current_;
}
inline void ClientToServer_Batteries_BatteryData::set_current(::google::protobuf::int32 value) {
  
  current_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.current)
}

// uint32 charge = 3;
inline void ClientToServer_Batteries_BatteryData::clear_charge() {
  charge_ = 0u;
}
inline ::google::protobuf::uint32 ClientToServer_Batteries_BatteryData::charge() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.charge)
  return charge_;
}
inline void ClientToServer_Batteries_BatteryData::set_charge(::google::protobuf::uint32 value) {
  
  charge_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.charge)
}

// int32 average_temperature = 4;
inline void ClientToServer_Batteries_BatteryData::clear_average_temperature() {
  average_temperature_ = 0;
}
inline ::google::protobuf::int32 ClientToServer_Batteries_BatteryData::average_temperature() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.average_temperature)
  return average_temperature_;
}
inline void ClientToServer_Batteries_BatteryData::set_average_temperature(::google::protobuf::int32 value) {
  
  average_temperature_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.average_temperature)
}

// int32 low_temperature = 5;
inline void ClientToServer_Batteries_BatteryData::clear_low_temperature() {
  low_temperature_ = 0;
}
inline ::google::protobuf::int32 ClientToServer_Batteries_BatteryData::low_temperature() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.low_temperature)
  return low_temperature_;
}
inline void ClientToServer_Batteries_BatteryData::set_low_temperature(::google::protobuf::int32 value) {
  
  low_temperature_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.low_temperature)
}

// int32 high_temperature = 6;
inline void ClientToServer_Batteries_BatteryData::clear_high_temperature() {
  high_temperature_ = 0;
}
inline ::google::protobuf::int32 ClientToServer_Batteries_BatteryData::high_temperature() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.high_temperature)
  return high_temperature_;
}
inline void ClientToServer_Batteries_BatteryData::set_high_temperature(::google::protobuf::int32 value) {
  
  high_temperature_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.high_temperature)
}

// uint32 low_voltage_cell = 7;
inline void ClientToServer_Batteries_BatteryData::clear_low_voltage_cell() {
  low_voltage_cell_ = 0u;
}
inline ::google::protobuf::uint32 ClientToServer_Batteries_BatteryData::low_voltage_cell() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.low_voltage_cell)
  return low_voltage_cell_;
}
inline void ClientToServer_Batteries_BatteryData::set_low_voltage_cell(::google::protobuf::uint32 value) {
  
  low_voltage_cell_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.low_voltage_cell)
}

// uint32 high_voltage_cell = 8;
inline void ClientToServer_Batteries_BatteryData::clear_high_voltage_cell() {
  high_voltage_cell_ = 0u;
}
inline ::google::protobuf::uint32 ClientToServer_Batteries_BatteryData::high_voltage_cell() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.high_voltage_cell)
  return high_voltage_cell_;
}
inline void ClientToServer_Batteries_BatteryData::set_high_voltage_cell(::google::protobuf::uint32 value) {
  
  high_voltage_cell_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.high_voltage_cell)
}

// repeated uint32 indv_voltage = 9;
inline int ClientToServer_Batteries_BatteryData::indv_voltage_size() const {
  return indv_voltage_.size();
}
inline void ClientToServer_Batteries_BatteryData::clear_indv_voltage() {
  indv_voltage_.Clear();
}
inline ::google::protobuf::uint32 ClientToServer_Batteries_BatteryData::indv_voltage(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
  return indv_voltage_.Get(index);
}
inline void ClientToServer_Batteries_BatteryData::set_indv_voltage(int index, ::google::protobuf::uint32 value) {
  indv_voltage_.Set(index, value);
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
}
inline void ClientToServer_Batteries_BatteryData::add_indv_voltage(::google::protobuf::uint32 value) {
  indv_voltage_.Add(value);
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ClientToServer_Batteries_BatteryData::indv_voltage() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
  return indv_voltage_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ClientToServer_Batteries_BatteryData::mutable_indv_voltage() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
  return &indv_voltage_;
}

// -------------------------------------------------------------------

// ClientToServer_Batteries

// .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
inline void ClientToServer_Batteries::clear_module_status() {
  module_status_ = 0;
}
inline ::telemetry_data::ClientToServer_ModuleStatus ClientToServer_Batteries::module_status() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.module_status)
  return static_cast< ::telemetry_data::ClientToServer_ModuleStatus >(module_status_);
}
inline void ClientToServer_Batteries::set_module_status(::telemetry_data::ClientToServer_ModuleStatus value) {
  
  module_status_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.module_status)
}

// repeated .telemetry_data.ClientToServer.Batteries.BatteryData low_power_batteries = 2;
inline int ClientToServer_Batteries::low_power_batteries_size() const {
  return low_power_batteries_.size();
}
inline void ClientToServer_Batteries::clear_low_power_batteries() {
  low_power_batteries_.Clear();
}
inline ::telemetry_data::ClientToServer_Batteries_BatteryData* ClientToServer_Batteries::mutable_low_power_batteries(int index) {
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return low_power_batteries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >*
ClientToServer_Batteries::mutable_low_power_batteries() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return &low_power_batteries_;
}
inline const ::telemetry_data::ClientToServer_Batteries_BatteryData& ClientToServer_Batteries::low_power_batteries(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return low_power_batteries_.Get(index);
}
inline ::telemetry_data::ClientToServer_Batteries_BatteryData* ClientToServer_Batteries::add_low_power_batteries() {
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return low_power_batteries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >&
ClientToServer_Batteries::low_power_batteries() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return low_power_batteries_;
}

// repeated .telemetry_data.ClientToServer.Batteries.BatteryData high_power_batteries = 3;
inline int ClientToServer_Batteries::high_power_batteries_size() const {
  return high_power_batteries_.size();
}
inline void ClientToServer_Batteries::clear_high_power_batteries() {
  high_power_batteries_.Clear();
}
inline ::telemetry_data::ClientToServer_Batteries_BatteryData* ClientToServer_Batteries::mutable_high_power_batteries(int index) {
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return high_power_batteries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >*
ClientToServer_Batteries::mutable_high_power_batteries() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return &high_power_batteries_;
}
inline const ::telemetry_data::ClientToServer_Batteries_BatteryData& ClientToServer_Batteries::high_power_batteries(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return high_power_batteries_.Get(index);
}
inline ::telemetry_data::ClientToServer_Batteries_BatteryData* ClientToServer_Batteries::add_high_power_batteries() {
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return high_power_batteries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >&
ClientToServer_Batteries::high_power_batteries() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return high_power_batteries_;
}

// -------------------------------------------------------------------

// ClientToServer_Sensors_ImuData

// bool operational = 1;
inline void ClientToServer_Sensors_ImuData::clear_operational() {
  operational_ = false;
}
inline bool ClientToServer_Sensors_ImuData::operational() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Sensors.ImuData.operational)
  return operational_;
}
inline void ClientToServer_Sensors_ImuData::set_operational(bool value) {
  
  operational_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Sensors.ImuData.operational)
}

// repeated float acc = 2;
inline int ClientToServer_Sensors_ImuData::acc_size() const {
  return acc_.size();
}
inline void ClientToServer_Sensors_ImuData::clear_acc() {
  acc_.Clear();
}
inline float ClientToServer_Sensors_ImuData::acc(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Sensors.ImuData.acc)
  return acc_.Get(index);
}
inline void ClientToServer_Sensors_ImuData::set_acc(int index, float value) {
  acc_.Set(index, value);
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Sensors.ImuData.acc)
}
inline void ClientToServer_Sensors_ImuData::add_acc(float value) {
  acc_.Add(value);
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Sensors.ImuData.acc)
}
inline const ::google::protobuf::RepeatedField< float >&
ClientToServer_Sensors_ImuData::acc() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Sensors.ImuData.acc)
  return acc_;
}
inline ::google::protobuf::RepeatedField< float >*
ClientToServer_Sensors_ImuData::mutable_acc() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Sensors.ImuData.acc)
  return &acc_;
}

// -------------------------------------------------------------------

// ClientToServer_Sensors

// .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
inline void ClientToServer_Sensors::clear_module_status() {
  module_status_ = 0;
}
inline ::telemetry_data::ClientToServer_ModuleStatus ClientToServer_Sensors::module_status() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Sensors.module_status)
  return static_cast< ::telemetry_data::ClientToServer_ModuleStatus >(module_status_);
}
inline void ClientToServer_Sensors::set_module_status(::telemetry_data::ClientToServer_ModuleStatus value) {
  
  module_status_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Sensors.module_status)
}

// repeated .telemetry_data.ClientToServer.Sensors.ImuData imu = 2;
inline int ClientToServer_Sensors::imu_size() const {
  return imu_.size();
}
inline void ClientToServer_Sensors::clear_imu() {
  imu_.Clear();
}
inline ::telemetry_data::ClientToServer_Sensors_ImuData* ClientToServer_Sensors::mutable_imu(int index) {
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.Sensors.imu)
  return imu_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData >*
ClientToServer_Sensors::mutable_imu() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Sensors.imu)
  return &imu_;
}
inline const ::telemetry_data::ClientToServer_Sensors_ImuData& ClientToServer_Sensors::imu(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Sensors.imu)
  return imu_.Get(index);
}
inline ::telemetry_data::ClientToServer_Sensors_ImuData* ClientToServer_Sensors::add_imu() {
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Sensors.imu)
  return imu_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData >&
ClientToServer_Sensors::imu() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Sensors.imu)
  return imu_;
}

// -------------------------------------------------------------------

// ClientToServer_Temperature

// sint32 temperature = 1;
inline void ClientToServer_Temperature::clear_temperature() {
  temperature_ = 0;
}
inline ::google::protobuf::int32 ClientToServer_Temperature::temperature() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Temperature.temperature)
  return temperature_;
}
inline void ClientToServer_Temperature::set_temperature(::google::protobuf::int32 value) {
  
  temperature_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Temperature.temperature)
}

// -------------------------------------------------------------------

// ClientToServer_EmergencyBrakes

// repeated bool brakes = 1;
inline int ClientToServer_EmergencyBrakes::brakes_size() const {
  return brakes_.size();
}
inline void ClientToServer_EmergencyBrakes::clear_brakes() {
  brakes_.Clear();
}
inline bool ClientToServer_EmergencyBrakes::brakes(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
  return brakes_.Get(index);
}
inline void ClientToServer_EmergencyBrakes::set_brakes(int index, bool value) {
  brakes_.Set(index, value);
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
}
inline void ClientToServer_EmergencyBrakes::add_brakes(bool value) {
  brakes_.Add(value);
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
}
inline const ::google::protobuf::RepeatedField< bool >&
ClientToServer_EmergencyBrakes::brakes() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
  return brakes_;
}
inline ::google::protobuf::RepeatedField< bool >*
ClientToServer_EmergencyBrakes::mutable_brakes() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
  return &brakes_;
}

// -------------------------------------------------------------------

// ClientToServer

// .telemetry_data.ClientToServer.Navigation navigation = 1;
inline bool ClientToServer::has_navigation() const {
  return this != internal_default_instance() && navigation_ != NULL;
}
inline void ClientToServer::clear_navigation() {
  if (GetArenaNoVirtual() == NULL && navigation_ != NULL) {
    delete navigation_;
  }
  navigation_ = NULL;
}
inline const ::telemetry_data::ClientToServer_Navigation& ClientToServer::_internal_navigation() const {
  return *navigation_;
}
inline const ::telemetry_data::ClientToServer_Navigation& ClientToServer::navigation() const {
  const ::telemetry_data::ClientToServer_Navigation* p = navigation_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.navigation)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Navigation*>(
      &::telemetry_data::_ClientToServer_Navigation_default_instance_);
}
inline ::telemetry_data::ClientToServer_Navigation* ClientToServer::release_navigation() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.navigation)
  
  ::telemetry_data::ClientToServer_Navigation* temp = navigation_;
  navigation_ = NULL;
  return temp;
}
inline ::telemetry_data::ClientToServer_Navigation* ClientToServer::mutable_navigation() {
  
  if (navigation_ == NULL) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Navigation>(GetArenaNoVirtual());
    navigation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.navigation)
  return navigation_;
}
inline void ClientToServer::set_allocated_navigation(::telemetry_data::ClientToServer_Navigation* navigation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete navigation_;
  }
  if (navigation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      navigation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navigation, submessage_arena);
    }
    
  } else {
    
  }
  navigation_ = navigation;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.navigation)
}

// .telemetry_data.ClientToServer.StateMachine state_machine = 2;
inline bool ClientToServer::has_state_machine() const {
  return this != internal_default_instance() && state_machine_ != NULL;
}
inline void ClientToServer::clear_state_machine() {
  if (GetArenaNoVirtual() == NULL && state_machine_ != NULL) {
    delete state_machine_;
  }
  state_machine_ = NULL;
}
inline const ::telemetry_data::ClientToServer_StateMachine& ClientToServer::_internal_state_machine() const {
  return *state_machine_;
}
inline const ::telemetry_data::ClientToServer_StateMachine& ClientToServer::state_machine() const {
  const ::telemetry_data::ClientToServer_StateMachine* p = state_machine_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.state_machine)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_StateMachine*>(
      &::telemetry_data::_ClientToServer_StateMachine_default_instance_);
}
inline ::telemetry_data::ClientToServer_StateMachine* ClientToServer::release_state_machine() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.state_machine)
  
  ::telemetry_data::ClientToServer_StateMachine* temp = state_machine_;
  state_machine_ = NULL;
  return temp;
}
inline ::telemetry_data::ClientToServer_StateMachine* ClientToServer::mutable_state_machine() {
  
  if (state_machine_ == NULL) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_StateMachine>(GetArenaNoVirtual());
    state_machine_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.state_machine)
  return state_machine_;
}
inline void ClientToServer::set_allocated_state_machine(::telemetry_data::ClientToServer_StateMachine* state_machine) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_machine_;
  }
  if (state_machine) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state_machine = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state_machine, submessage_arena);
    }
    
  } else {
    
  }
  state_machine_ = state_machine;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.state_machine)
}

// .telemetry_data.ClientToServer.Motors motors = 3;
inline bool ClientToServer::has_motors() const {
  return this != internal_default_instance() && motors_ != NULL;
}
inline void ClientToServer::clear_motors() {
  if (GetArenaNoVirtual() == NULL && motors_ != NULL) {
    delete motors_;
  }
  motors_ = NULL;
}
inline const ::telemetry_data::ClientToServer_Motors& ClientToServer::_internal_motors() const {
  return *motors_;
}
inline const ::telemetry_data::ClientToServer_Motors& ClientToServer::motors() const {
  const ::telemetry_data::ClientToServer_Motors* p = motors_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.motors)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Motors*>(
      &::telemetry_data::_ClientToServer_Motors_default_instance_);
}
inline ::telemetry_data::ClientToServer_Motors* ClientToServer::release_motors() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.motors)
  
  ::telemetry_data::ClientToServer_Motors* temp = motors_;
  motors_ = NULL;
  return temp;
}
inline ::telemetry_data::ClientToServer_Motors* ClientToServer::mutable_motors() {
  
  if (motors_ == NULL) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Motors>(GetArenaNoVirtual());
    motors_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.motors)
  return motors_;
}
inline void ClientToServer::set_allocated_motors(::telemetry_data::ClientToServer_Motors* motors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete motors_;
  }
  if (motors) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      motors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motors, submessage_arena);
    }
    
  } else {
    
  }
  motors_ = motors;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.motors)
}

// .telemetry_data.ClientToServer.Batteries batteries = 4;
inline bool ClientToServer::has_batteries() const {
  return this != internal_default_instance() && batteries_ != NULL;
}
inline void ClientToServer::clear_batteries() {
  if (GetArenaNoVirtual() == NULL && batteries_ != NULL) {
    delete batteries_;
  }
  batteries_ = NULL;
}
inline const ::telemetry_data::ClientToServer_Batteries& ClientToServer::_internal_batteries() const {
  return *batteries_;
}
inline const ::telemetry_data::ClientToServer_Batteries& ClientToServer::batteries() const {
  const ::telemetry_data::ClientToServer_Batteries* p = batteries_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.batteries)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Batteries*>(
      &::telemetry_data::_ClientToServer_Batteries_default_instance_);
}
inline ::telemetry_data::ClientToServer_Batteries* ClientToServer::release_batteries() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.batteries)
  
  ::telemetry_data::ClientToServer_Batteries* temp = batteries_;
  batteries_ = NULL;
  return temp;
}
inline ::telemetry_data::ClientToServer_Batteries* ClientToServer::mutable_batteries() {
  
  if (batteries_ == NULL) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Batteries>(GetArenaNoVirtual());
    batteries_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.batteries)
  return batteries_;
}
inline void ClientToServer::set_allocated_batteries(::telemetry_data::ClientToServer_Batteries* batteries) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete batteries_;
  }
  if (batteries) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      batteries = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, batteries, submessage_arena);
    }
    
  } else {
    
  }
  batteries_ = batteries;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.batteries)
}

// .telemetry_data.ClientToServer.Sensors sensors = 5;
inline bool ClientToServer::has_sensors() const {
  return this != internal_default_instance() && sensors_ != NULL;
}
inline void ClientToServer::clear_sensors() {
  if (GetArenaNoVirtual() == NULL && sensors_ != NULL) {
    delete sensors_;
  }
  sensors_ = NULL;
}
inline const ::telemetry_data::ClientToServer_Sensors& ClientToServer::_internal_sensors() const {
  return *sensors_;
}
inline const ::telemetry_data::ClientToServer_Sensors& ClientToServer::sensors() const {
  const ::telemetry_data::ClientToServer_Sensors* p = sensors_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.sensors)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Sensors*>(
      &::telemetry_data::_ClientToServer_Sensors_default_instance_);
}
inline ::telemetry_data::ClientToServer_Sensors* ClientToServer::release_sensors() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.sensors)
  
  ::telemetry_data::ClientToServer_Sensors* temp = sensors_;
  sensors_ = NULL;
  return temp;
}
inline ::telemetry_data::ClientToServer_Sensors* ClientToServer::mutable_sensors() {
  
  if (sensors_ == NULL) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Sensors>(GetArenaNoVirtual());
    sensors_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.sensors)
  return sensors_;
}
inline void ClientToServer::set_allocated_sensors(::telemetry_data::ClientToServer_Sensors* sensors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensors_;
  }
  if (sensors) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensors, submessage_arena);
    }
    
  } else {
    
  }
  sensors_ = sensors;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.sensors)
}

// .telemetry_data.ClientToServer.Temperature temperature = 6;
inline bool ClientToServer::has_temperature() const {
  return this != internal_default_instance() && temperature_ != NULL;
}
inline void ClientToServer::clear_temperature() {
  if (GetArenaNoVirtual() == NULL && temperature_ != NULL) {
    delete temperature_;
  }
  temperature_ = NULL;
}
inline const ::telemetry_data::ClientToServer_Temperature& ClientToServer::_internal_temperature() const {
  return *temperature_;
}
inline const ::telemetry_data::ClientToServer_Temperature& ClientToServer::temperature() const {
  const ::telemetry_data::ClientToServer_Temperature* p = temperature_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.temperature)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Temperature*>(
      &::telemetry_data::_ClientToServer_Temperature_default_instance_);
}
inline ::telemetry_data::ClientToServer_Temperature* ClientToServer::release_temperature() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.temperature)
  
  ::telemetry_data::ClientToServer_Temperature* temp = temperature_;
  temperature_ = NULL;
  return temp;
}
inline ::telemetry_data::ClientToServer_Temperature* ClientToServer::mutable_temperature() {
  
  if (temperature_ == NULL) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Temperature>(GetArenaNoVirtual());
    temperature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.temperature)
  return temperature_;
}
inline void ClientToServer::set_allocated_temperature(::telemetry_data::ClientToServer_Temperature* temperature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete temperature_;
  }
  if (temperature) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      temperature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, temperature, submessage_arena);
    }
    
  } else {
    
  }
  temperature_ = temperature;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.temperature)
}

// .telemetry_data.ClientToServer.EmergencyBrakes emergency_brakes = 7;
inline bool ClientToServer::has_emergency_brakes() const {
  return this != internal_default_instance() && emergency_brakes_ != NULL;
}
inline void ClientToServer::clear_emergency_brakes() {
  if (GetArenaNoVirtual() == NULL && emergency_brakes_ != NULL) {
    delete emergency_brakes_;
  }
  emergency_brakes_ = NULL;
}
inline const ::telemetry_data::ClientToServer_EmergencyBrakes& ClientToServer::_internal_emergency_brakes() const {
  return *emergency_brakes_;
}
inline const ::telemetry_data::ClientToServer_EmergencyBrakes& ClientToServer::emergency_brakes() const {
  const ::telemetry_data::ClientToServer_EmergencyBrakes* p = emergency_brakes_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.emergency_brakes)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_EmergencyBrakes*>(
      &::telemetry_data::_ClientToServer_EmergencyBrakes_default_instance_);
}
inline ::telemetry_data::ClientToServer_EmergencyBrakes* ClientToServer::release_emergency_brakes() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.emergency_brakes)
  
  ::telemetry_data::ClientToServer_EmergencyBrakes* temp = emergency_brakes_;
  emergency_brakes_ = NULL;
  return temp;
}
inline ::telemetry_data::ClientToServer_EmergencyBrakes* ClientToServer::mutable_emergency_brakes() {
  
  if (emergency_brakes_ == NULL) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_EmergencyBrakes>(GetArenaNoVirtual());
    emergency_brakes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.emergency_brakes)
  return emergency_brakes_;
}
inline void ClientToServer::set_allocated_emergency_brakes(::telemetry_data::ClientToServer_EmergencyBrakes* emergency_brakes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete emergency_brakes_;
  }
  if (emergency_brakes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      emergency_brakes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emergency_brakes, submessage_arena);
    }
    
  } else {
    
  }
  emergency_brakes_ = emergency_brakes;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.emergency_brakes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace telemetry_data

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::telemetry_data::ServerToClient_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::telemetry_data::ServerToClient_Command>() {
  return ::telemetry_data::ServerToClient_Command_descriptor();
}
template <> struct is_proto_enum< ::telemetry_data::ClientToServer_StateMachine_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::telemetry_data::ClientToServer_StateMachine_State>() {
  return ::telemetry_data::ClientToServer_StateMachine_State_descriptor();
}
template <> struct is_proto_enum< ::telemetry_data::ClientToServer_ModuleStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::telemetry_data::ClientToServer_ModuleStatus>() {
  return ::telemetry_data::ClientToServer_ModuleStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_message_2eproto
